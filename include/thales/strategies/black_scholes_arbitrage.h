#ifndef THALES_STRATEGIES_BLACK_SCHOLES_ARBITRAGE_H
#define THALES_STRATEGIES_BLACK_SCHOLES_ARBITRAGE_H

#include <thales/strategies/strategy_base.h>
#include <thales/models/black_scholes.h>
#include <vector>
#include <string>
#include <unordered_map>

namespace thales {
namespace strategies {

/**
 * @class BlackScholesArbitrage
 * @brief Strategy that looks for arbitrage opportunities based on Black-Scholes pricing.
 * 
 * This strategy compares market prices of options with their theoretical prices
 * calculated using the Black-Scholes model. If the market price is significantly
 * different from the theoretical price, it generates a trading signal.
 */
class BlackScholesArbitrage : public StrategyBase {
public:
    /**
     * @brief Constructor
     * @param config The configuration for the strategy
     */
    explicit BlackScholesArbitrage(const utils::Config& config);
    
    /**
     * @brief Destructor
     */
    ~BlackScholesArbitrage() override = default;
    
    /**
     * @brief Initialize the strategy
     * @return true if initialization was successful, false otherwise
     */
    bool initialize() override;
    
    /**
     * @brief Execute the strategy
     * @param marketData The market data to use for execution
     * @param portfolio The current portfolio
     * @return A vector of signals generated by the strategy
     */
    std::vector<Signal> execute(
        const std::vector<data::MarketData>& marketData,
        const core::Portfolio& portfolio
    ) override;
    
    /**
     * @brief Get the symbols that the strategy is interested in
     * @return A vector of symbols
     */
    std::vector<std::string> getSymbols() const override;

private:
    // Strategy parameters
    double minPriceDiscrepancy_;
    double minVolatility_;
    double maxVolatility_;
    int minDaysToExpiration_;
    int maxDaysToExpiration_;
    
    // Symbols to trade
    std::vector<std::string> symbols_;
    
    // Historical volatility cache
    std::unordered_map<std::string, double> historicalVolatility_;
    
    // Private methods
    double calculateHistoricalVolatility(const std::vector<data::MarketData>& marketData, const std::string& symbol);
    double calculateRiskFreeRate() const;
    double calculateTimeToExpiration(const std::string& expirationDate) const;
    bool isOptionEligible(const data::OptionData& option) const;
    Signal generateSignal(const data::OptionData& option, double theoreticalPrice);
};

} // namespace strategies
} // namespace thales

#endif // THALES_STRATEGIES_BLACK_SCHOLES_ARBITRAGE_H
